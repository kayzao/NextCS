/* autogenerated by Processing revision 1282 on 2022-05-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class OrbitalMotion extends PApplet {

/*=====================
  Driver File

  On startup, a new OrbList will be displayed
  with 2 sentinel orbs and 2 regular orbs.

  Pressing space will allow the orbs to run,
  applying gravity and the spring force to
  each orb.

  Pressing m will cycle through different
  interactice modes, explained further in
  keyPressed anad mousePressed. The current
  mode will be displayed in the lower left corner.

  Clicking the mouse will either add a new
  orb or modify and existing orb. More details
  provided in mousePressed.
  =====================*/

int DELETE_MODE = 0;
int GROW_MODE = 1;
int SHRINK_MODE = 2;
int ADD_FIXED_MODE = 3;
int clickMode;

boolean moving;
OrbList slinky;
float GRAVITY = 0.2f;
PVector g;

 public void setup() {
  /* size commented out by preprocessor */;
  clickMode = DELETE_MODE;
  moving = false;
  g = new PVector(0, GRAVITY);
  makeSlinky(2, 100);
}

 public void draw() {
  background(255);
  if (moving) {
    slinky.applyExternalForce(g);
    /*
    println(slinky);
    println("========= applied external force =========");
    */
    slinky.applySprings();
    /*
    println(slinky);
    println("========= applied spring =========");
    */
    slinky.run();
    /*
    println(slinky);
    println("========= RUN() =========");
    */
  }
  slinky.display();
  displayMode();
}

/*=====================
  makeSlinky(int numParts, int y)

  Create a new OrbList with numParts orbs in
  addition to the 2 sentinel nodes (so if
  numParts = 2, 4 nodes in total).

  Every node should have the provided y value.

  The 2 sentinel nodes should be at (50, y)
  and (450, y).

  The rest of the nodes should be regular
  OrbNodes evely spaced between the two
  sentinel nodes.
  =====================*/
 public void makeSlinky(int numParts, int y) {
  int x0 = 50;
  int x1 = 450;
  slinky = new OrbList(50, y, x1, y);
  for(int i = 0; i < numParts; i++){
    slinky.append(x0 + ((x1 - x0) / (numParts + 1)) * (i+1), y, false);
  }
}

/*=====================
  keyPressed

  Respond to keyboard events in the following way:

  ' ' (space): set moving to it's opposite value.
  'r': Call makeSlinky with at least 2 nodes.
  'm': Cycle through the different clickMode values going
      DELETE_MODE, GROW_MODE, SHRINK_MODE, ADD_FIXED_MODE,
      back to DELETE_MODE and so on.
  =====================*/
 public void keyPressed() {
  if(key == ' ') {
    moving = !moving;
  }
  if(key == 'r') {
    makeSlinky(0, mouseY);
  }
  if(key == 'm') {
    clickMode = (clickMode + 1) % 4;
  }
  if(key == 'k') {
    println(slinky);
  }
}


/*=====================
  mousePressed

  Respond to mouse pressed based on clickMode:

  First, check if the mouse is currently over an
  existing orb.

  If the mouse is selecting  a current (non sentinel)
  orb, perform the following action based on the
  current value of clickMode.
    DELETE_MODE: Remove the selected orb from the list.
    GROW_MODE: Increase the size of the orb by 1.
    SHRINK_MODE: Decrease the size of the orb by 1.
  =====================*/
 public void mousePressed() {
  if(slinky.selectNode(mouseX, mouseY) == null){ //mouse is not over orb
    //add new orb based on where mouseX is
    OrbNode nxt = slinky.findNextNode(mouseX);
    OrbNode prev = nxt.getPrev();
    OrbNode n;
    if(clickMode == ADD_FIXED_MODE) n = new FixedOrbNode(mouseX, mouseY);
    else n = new OrbNode(mouseX, mouseY);
    nxt.setPrev(n);
    n.setNext(nxt);
    n.setPrev(prev);
    prev.setNext(n);
  } else {
    if(clickMode == DELETE_MODE) slinky.removeNode(slinky.selectNode(mouseX, mouseY));
    else if(clickMode == GROW_MODE) slinky.selectNode(mouseX, mouseY).setSize(slinky.selectNode(mouseX, mouseY).getSize() + 1);
    else if(clickMode == SHRINK_MODE) slinky.selectNode(mouseX, mouseY).setSize(slinky.selectNode(mouseX, mouseY).getSize() - 1);
  }
}//mousePressed

/*=====================
  displayMode should be left unmodified.
  =====================*/
 public void displayMode() {
  String message = "DELETE_MODE";
  if (clickMode == GROW_MODE) {
    message = "GROW MODE";
  }
  else if (clickMode == SHRINK_MODE) {
    message = "SHRINK MODE";
  }
  else if (clickMode == ADD_FIXED_MODE) {
    message = "ADD FIXED MODE";
  }
  fill(0);
  textSize(20);
  text(message, 10, height-10);
}
public class FixedOrbNode extends OrbNode {
  public FixedOrbNode(int x, int y) {
    super(x, y);
  }

  @Override
  public void run() {
    
  }
}
public class OrbList {

  private OrbNode front;
  private OrbNode back;

  /*=====================
    Constructor

    Create FixedOrbs at (x0, y0) and (x1, y1).
    Set front to the orb at (x0, y0).
    Set back to the orb at (x1, y1).
    Connect front and back accordingly.
    =====================*/
  public OrbList(int x0, int y0, int x1, int y1) {
    front = new FixedOrbNode(x0, y0);
    back = new FixedOrbNode(x1, y1);
    front.setNext(back);
    back.setPrev(front);
  }

  public OrbNode getFront() {
    return front;
  }

  public OrbNode getBack() {
    return back;
  }

  public void addFront(int x, int y, boolean fixed) {
    OrbNode o;
    if(fixed) o = new FixedOrbNode(x, y);
    else o = new OrbNode(x, y);
    OrbNode nxt = front.getNext();
    nxt.setPrev(o);
    o.setNext(nxt);
    o.setPrev(front);
    front.setNext(o);
  }

  public void append(int x, int y, boolean fixed) {
    OrbNode o;
    if(fixed) o = new FixedOrbNode(x, y);
    else o = new OrbNode(x, y);
    OrbNode prv = back.getPrev();
    prv.setNext(o);
    o.setPrev(prv);
    o.setNext(back);
    back.setPrev(o);
  }

  public void removeNode(OrbNode pn) {
    if(pn.getPrev() == null || pn.getNext() == null) return;
    OrbNode prv = pn.getPrev();
    OrbNode nxt = pn.getNext();
    prv.setNext(nxt);
    nxt.setPrev(prv);
  }


  /*=====================
    selectNode(int x, int y)

    If (x, y) is a position inside a NON
    SENTINEL node in this list (as defined
    by the constains()method in OrbNode),
    return a reference to that node.

    In all other cases, return null.
    =====================*/
  public OrbNode selectNode(int x, int y) {
    OrbNode i = front;
    while(i != null) {
      if(i.contains(new PVector(x, y))) return i;
      i = i.getNext();
    }
    return null;
  }
  

  //finds the leftmost node right of the given x pos
   public OrbNode findNextNode(float x) {
    OrbNode i = front.getNext();
    if(x < i.getPos().x) return i;
    while(i != null) {
      if(i.getPos().x >= x) return i;
      i = i.getNext();
    }
    return back;
  }

  public void display() {
    OrbNode current = front;
    while (current != null) {
      current.display();
      current = current.next;
    }
  }

  public void applySprings() {
    OrbNode current = front;
    while (current != null) {
      current.applySpringForce();
      current = current.next;
    }
  }

  public void applyExternalForce(PVector force) {
    OrbNode current = front;
    while (current != null) {
      current.applyForce(force);
      current = current.next;
    }
  }

  public int detectMouse(){
    OrbNode current = front.getNext();
    int index = 1;
    while(current.getNext() != null){ //while current is not the back sentinel
      if(current.contains(new PVector(mouseX, mouseY))){
        return index;
      }
      index++;
      current = current.getNext();
    }
    return -1;
  }

  public void run() {
    OrbNode current = front;
    while (current.getNext() != null) {
      current.run();
      current = current.next;
    }
  }

  public String toString() {
    String s = "";
    OrbNode current = front;
    while (current != null) {
      s+= current;
      current = current.next;
    }
    return s;
  }

}
/*=====================
  This class does not need to be modified.

  It is the same OrbNode class we've been working on with
  2 important changes.

  0) There is now a concept of mass applied in run()
     Mass is determined as osize/PART_SIZE.
      When an OrbNode is made, it has a mass of 1.
    There is a method embiggen(f) which will add f
    to osize.
    You will use embiggen in the main drive file.

  1) There is a method contains(p) which takes a
     PVector and returns true if p is inside the
     OrbNode
  =====================*/
public class OrbNode {

  static final float SPRING_LEN = 50;
  static final float SPRING_CONST = 0.005f;
  static final float DAMPING = 0.995f; //1 is no damping, lower numbers is more aggressive damping
  static final int PART_SIZE = 15;

  private PVector position;
  private PVector velocity;
  private PVector acceleration;
  private int osize;
  private float mass;
  private int c;

  private OrbNode next;
  private OrbNode previous;

  public OrbNode(int x, int y) {
    position = new PVector(x, y);
    velocity = new PVector(0, 0);
    acceleration = new PVector(0, 0);
    osize = PART_SIZE;
    c = color(240, 140, 40);
  }

  public OrbNode getPrev(){
    return previous;
  }
  
  public OrbNode getNext(){
    return next;
  }

  public PVector getPos(){
    return position;
  }

  public int getSize(){
    return osize;
  }

  public void setPrev(OrbNode previous){
    this.previous = previous;
  }

  public void setNext(OrbNode next){
    this.next = next;
  }

  public void setColor(int c){
    this.c = c;
  }
  
  public void setSize(int size) {
    osize = size;
  }

  public boolean contains(PVector p) {
    float d = position.dist(p);
    return d <= osize;
  }

  public void run() {
    acceleration.mult(osize/PART_SIZE);
    velocity.add(acceleration);
    velocity.mult(DAMPING);
    position.add(velocity);
    acceleration.mult(0);
    if (checkYBounds()) {
      if(position.y < osize/2) position.y = osize/2;
      else if(position.y > height - osize/2) position.y = height - osize/2;
      velocity.y*= -0.9f;
      position.y+= velocity.y;
    }
    if (checkXBounds()) {
      if(position.x < osize/2) position.x = osize/2;
      else if(position.x > width - osize/2) position.x = width - osize/2;
      velocity.x*= -0.9f;
      position.x+= velocity.x;
    }
  }

  public void applyForce(PVector f) {
    acceleration.add(f);
  }

  public boolean checkYBounds() {
    boolean check = position.y <= osize/2;
    check = check || position.y >= height - osize/2;
    return check;
  }

  public boolean checkXBounds() {
    boolean check = position.x <= osize/2;
    check = check || position.x >= width - osize/2;
    return check;
  }

  public void display() {
    if (next != null) {
      stroke(40, 200, 190);
      line(position.x+1, position.y+1, next.position.x+1, next.position.y+1);
    }
    if (previous != null) {
      stroke(210, 50, 150);
      line(position.x-1, position.y-1, previous.position.x-1, previous.position.y-1);
    }
    stroke(0);
    fill(c);
    circle(position.x, position.y, osize);
  }

  public String toString() {
    return position.toString();
  }

  public void applySpringForce() {
    if (next != null) {
      velocity.add(calculateSpringForce(next));
    }
    if (previous != null) {
      velocity.add(calculateSpringForce(previous));
    }
  }


  public PVector calculateSpringForce(OrbNode other) {
    float dist = position.dist(other.position);
    float displacement = dist - SPRING_LEN;
    float springForce = displacement * SPRING_CONST;

    float xDiff = other.position.x - position.x;
    float yDiff = other.position.y - position.y;
    float xForce = springForce * xDiff/dist;
    float yForce = springForce * yDiff/dist;

    return new PVector(xForce, yForce);
  }
}


  public void settings() { size(500, 500); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "OrbitalMotion" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}

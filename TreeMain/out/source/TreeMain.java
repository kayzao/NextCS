/* autogenerated by Processing revision 1282 on 2022-05-20 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class TreeMain extends PApplet {

Tree fir;
int state = 0;

 public void setup() {
  /* size commented out by preprocessor */;
  fir = new Tree(width / 2, 20, 5, true);
  println("SPACE to print nodes in preorder, inorder, and postorder form");
  println("R to reset");
  println("N to print number of nodes");
  println("H to print height of tree");
  println("C to color nodes based on height");
  println("=====================================");

}

 public void draw(){
  background(200);
  String str;
  if(state == 0) {
    fir.inOrderDisplay();
    str = "inOrderDisplay";
  } else if(state == 1){
    fir.postOrderDisplay();
    str = "postOrderDisplay";
  } else {
    fir.preOrderDisplay();
    str = "preOrderDisplay";
  }
  fill(0);
  textSize(30);
  text(str, 100, 20);
}

 public void mouseReleased() {
  state = (state + 1) % 3;
}

 public void keyPressed(){
  if(key == ' '){
    println("order of nodes in preorder form: " + fir.preOrder(fir.getRoot()));
  }
  if(key == 'r'){
    fir = new Tree(width / 2, 20, 5, true);
  }
  if(key == 'n'){
    println("number of nodes: " + fir.numNodes());
  }
  if(key == 'h'){
    println("height: " + fir.getHeight());
  }
  if(key == 'c'){
    fir.colorCode();
    println("colored nodes based on height");
  }
}
class Tree{
  private TreeNode root;
  private int totalLevels;
  private int codeColor, defaultColor;

  public Tree(int x, int y, int numLevels, boolean random){
    totalLevels = numLevels;
    if(!random) root = makeTree(x, y, numLevels);
    else root = makeRandomTree(x, y, numLevels);
    codeColor = color(100, 205, 255);
    defaultColor = color(255);
  }

  public TreeNode makeTree(int x, int y, int numLevels){
    if(numLevels <= 0) return null;
    TreeNode root = new TreeNode(x, y);
    TreeNode left = makeTree(x - PApplet.parseInt(width / (pow(2, (totalLevels - numLevels) +2))), min(y + 20 * numLevels, y+50), numLevels - 1);
    TreeNode right = makeTree(x + PApplet.parseInt(width / (pow(2, (totalLevels - numLevels) +2))), min(y + 20 * numLevels, y+50), numLevels - 1);
    root.setChar((PApplet.parseChar(PApplet.parseInt(random(1) * 26) + 97)));
    root.setLeft(left);
    root.setRight(right);
    return root;
  }

  public TreeNode makeRandomTree(int x, int y, int numLevels){
    if(numLevels <= 0) return null;
    TreeNode root = new TreeNode(x, y);
    if(random(1) < ((numLevels * 1.0f) / (totalLevels * 1.0f))){
      TreeNode left = makeRandomTree(x - PApplet.parseInt(width / (pow(2, (totalLevels - numLevels) +2))), min(y + 20 * numLevels, y+50), numLevels - 1);
      root.setLeft(left);
    }
    if(random(1) < ((numLevels * 1.0f) / (totalLevels * 1.0f))){
      TreeNode right = makeRandomTree(x + PApplet.parseInt(width / (pow(2, (totalLevels - numLevels) +2))), min(y + 20 * numLevels, y+50), numLevels - 1);
      root.setRight(right);
    }
    root.setChar((PApplet.parseChar(PApplet.parseInt(random(1) * 26) + 97)));    
    return root;
  }

  public TreeNode getRoot(){
    return root;
  }

  public int getHeight(){
    return getHeightRecursive(root);
  }

  private int getHeightRecursive(TreeNode root){
    if(root == null) return 0;
    return 1 + max(getHeightRecursive(root.getLeft()), getHeightRecursive(root.getRight()));
  }

  public int numNodes(){
    return numNodesRecursive(root);
  }

  private int numNodesRecursive(TreeNode root){
    if(root == null) return 0;
    return 1 + numNodesRecursive(root.getLeft()) + numNodesRecursive(root.getRight());
  }

  public void colorCode(){
    colorCodeRecursive(root);
  }

  public void colorCodeRecursive(TreeNode root){
    if(root == null) return;
    if(getHeightRecursive(root.left) == getHeightRecursive(root.right)){
      root.setColor(codeColor);
    } else {
      root.setColor(defaultColor);
    }
    colorCodeRecursive(root.left);
    colorCodeRecursive(root.right);
  }

  public String preOrder(TreeNode tn){
    if(tn == null) return "";
    return tn.c + preOrder(tn.getLeft()) + preOrder(tn.getRight());
  }

  public String inOrder(TreeNode tn){
    if(tn == null) return "";
    return tn.c + preOrder(tn.getLeft()) + preOrder(tn.getRight());
  }

  public String postOrder(TreeNode tn){
    if(tn == null) return "";
    return tn.c + preOrder(tn.getLeft()) + preOrder(tn.getRight());
  }

  public void inOrderDisplay(){
    inOrderDisplay(root);
  }

  private void inOrderDisplay(TreeNode root){
    if(root == null) return;
    inOrderDisplay(root.getLeft());
    root.display();
    inOrderDisplay(root.getRight());
  }

  public void postOrderDisplay(){
    postOrderDisplay(root);
  }
  
  private void postOrderDisplay(TreeNode root){
    if(root == null) return;
    postOrderDisplay(root.getLeft());
    postOrderDisplay(root.getRight());
    root.display();
  }

  public void preOrderDisplay(){
    preOrderDisplay(root);
  }

  private void preOrderDisplay(TreeNode root){
    if(root == null) return;
    root.display();
    preOrderDisplay(root.getLeft());
    preOrderDisplay(root.getRight());
  }
}
class TreeNode {
  private PVector pos;
  private float psize; //diameter
  private int fillCol = color(255);
  private final int col_left = color(240,0,0);
  private final int col_right = color(50,250,50);
  private String name;
  private TreeNode left, right;
  private char c;
  
  public TreeNode(int x, int y) {
    pos = new PVector(x,y);
    psize = 20;
    c = PApplet.parseChar(PApplet.parseInt(random(1) * 26) + 97);
  }

  public PVector getPos(){
    return pos;
  }

  public TreeNode getLeft(){
    return left;
  }

  public TreeNode getRight(){
    return right;
  }

  public char getChar(){
    return c;
  }

  public void setChar(char c){
    this.c = c;
  }

  public void setColor(int col){
    fillCol = col;
  }

  public void setLeft(TreeNode left){
    this.left = left;
  }

  public void setRight(TreeNode right){
    this.right = right;
  }

  public void setPos(PVector pos){
    this.pos = pos;
  }
 
  public void display() {
    stroke(0);
    fill(fillCol);
    circle(pos.x, pos.y, psize);
    //draw lines to left and right
    float OFFSET = 3;
    if (left != null) {
      stroke(col_left);
      line(pos.x - OFFSET, pos.y - 0, left.pos.x - OFFSET, left.pos.y - 0);
    }
    if (right != null) {
      stroke(col_right);
      line(pos.x + OFFSET, pos.y + 0, right.pos.x + OFFSET, right.pos.y + 0);
    }

    textAlign(CENTER);
    textSize(15);
    fill(0);
    text(c, pos.x, pos.y + psize / 3);
  }


}


  public void settings() { size(800, 500); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "TreeMain" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}

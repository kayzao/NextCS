/* autogenerated by Processing revision 1282 on 2022-04-25 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class RocketLab extends PApplet {

int NUM_MOVES = 600;
int goalX, goalY, goalSideLength = 50;
int moveCount;
int numRockets = 10;
int generationCount = 0;
int obstacleStartX, obstacleStartY, obstacleMinW, obstacleMaxW, obstacleMinL, obstacleMaxL;
float mutationRate;
Population pop;
int[][] obstacles;
boolean autoMode;
boolean obstaclesEnabled;
int OBSTACLE_COLOR = color(175);

 public void setup() {
  /* size commented out by preprocessor */;
  frameRate(240);
  autoMode = false;
  obstaclesEnabled = true;
  mutationRate = 0.03f;
  if (random(1) < (1.0f / 3.0f)) { //along right side
    goalX = width - goalSideLength;
    goalY = PApplet.parseInt(random(goalSideLength * 0.5f, height - goalSideLength * 0.5f));
  } else if (random(1) < 0.5f) { //along top side
    goalX = PApplet.parseInt(random(goalSideLength * 0.5f, width - goalSideLength * 0.5f));
    goalY = goalSideLength;
  } else { //along bottom side
    goalX = PApplet.parseInt(random(goalSideLength * 0.5f, width - goalSideLength * 0.5f));
    goalY = height - goalSideLength;
  }
  pop = new Population(numRockets, mutationRate);
  pop.randomPop();
  moveCount = 0;
  pop.setGoal(goalX, goalY, goalSideLength);
  pop.setFitness();
  //In the future make the number of obstacles change by keyboard input
  obstacleStartX = 100;
  obstacleStartY = 100;
  obstacleMinW = 10;
  obstacleMaxW = 75;
  obstacleMinL = 10;
  obstacleMaxL = 75;
  obstacles = new int[PApplet.parseInt(random(1, 10))][4];
  if(obstacles.length <= 0) obstaclesEnabled = false;
  if(obstaclesEnabled) createObstacles();
  println("========================== WELCOME ==========================");
  println("Press: R to randomize layout, M to evolve rockets, SPACE to enable autonomous mode");
  println("       W and S to change the mutation rate, and O to toggle on/off obstacles");
  println("=============================================================");
}

 public void draw() {
  background(255);
  rectMode(CENTER);
  drawGoal();
  if(obstaclesEnabled || moveCount > NUM_MOVES) drawObstacles();
  if (moveCount <= NUM_MOVES) {
    pop.display(false, true);
    moveCount++;
  } else {
    if (autoMode) evolve();
    else pop.display(true, false);
  }

  fill(255, 255, 255, 175);
  stroke(200);
  rectMode(CORNER);
  String m0 = "GEN " + generationCount + " | AUTO MODE: " + (autoMode ? "ACTIVE" : "INACTIVE") + " | OBSTACLES: " + (obstaclesEnabled ? "ENABLED" : "DISABLED");
  String m1 = "MUTATION RATE: " + roundDigits(pop.getMutationRate(), 3);
  rect(11, 0, m0.length() * 6, 25, 5);
  fill(0);
  text(m0, 20, 11);
  text(m1, 60, 22);

  pop.setFitness();
}

 public void keyPressed() {

  if (key == 'r') {
    if (generationCount > 0) println("=============== RESET: GENERATION 0 ===============");
    if(obstaclesEnabled){
      obstacles = new int[PApplet.parseInt(random(1, 10))][4];
      createObstacles();
    } else {
      obstacles = new int[0][4];
    }
    generationCount = 0;
    if (random(1) < (1.0f / 3.0f)) { //along right side
      goalX = width - goalSideLength;
      goalY = PApplet.parseInt(random(goalSideLength * 0.5f, height - goalSideLength * 0.5f));
    } else if (random(1) < 0.5f) { //along top side
      goalX = PApplet.parseInt(random(goalSideLength * 0.5f, width - goalSideLength * 0.5f));
      goalY = goalSideLength;
    } else { //along bottom side
      goalX = PApplet.parseInt(random(goalSideLength * 0.5f, width - goalSideLength * 0.5f));
      goalY = height - goalSideLength;
    }
    pop = new Population(numRockets, mutationRate);
    pop.randomPop();
    moveCount = 0;
    pop.setGoal(goalX, goalY, goalSideLength);
    pop.setFitness();
  }

  if (key == 'm' && moveCount > NUM_MOVES) {
    evolve();
  }

  if (key == ' ') {
    autoMode = !autoMode;
  }

  if (key == 'w') {
    mutationRate += 0.001f;
    pop.setMutationRate(mutationRate);
    mutationRate = pop.getMutationRate();
  }
  if (key == 's') {
    mutationRate -= 0.001f;
    pop.setMutationRate(mutationRate);
    mutationRate = pop.getMutationRate();
  }
  if (key == 'o'){
    if(moveCount < NUM_MOVES) return;
    obstaclesEnabled = !obstaclesEnabled;
    if(obstaclesEnabled){
      obstacles = new int[0][4];
      obstacles = new int[PApplet.parseInt(random(1, 10))][4];
      createObstacles();
    } 
  }
}

 public void drawGoal() {
  fill(255, 255, 0);
  stroke(0);
  strokeWeight(1);
  rectMode(CENTER);
  rect(goalX, goalY, goalSideLength / 2, goalSideLength / 2);
}

 public void createObstacles(){
  for(int i = 0; i < obstacles.length; i++){
    obstacles[i][0] = PApplet.parseInt(random(obstacleStartX, width - obstacleStartX - obstacleMaxW));
    obstacles[i][1] = PApplet.parseInt(random(obstacleStartY, height - obstacleStartY - obstacleMaxL));
    obstacles[i][2] = PApplet.parseInt(random(obstacleMinW, obstacleMaxW));
    obstacles[i][3] = PApplet.parseInt(random(obstacleMinL, obstacleMaxL));
  }
}

 public void drawObstacles(){
  rectMode(CENTER);
  for(int i = 0; i < obstacles.length; i++){
    fill(OBSTACLE_COLOR);
    rect(obstacles[i][0], obstacles[i][1], obstacles[i][2], obstacles[i][3]);
  }
}

 public void evolve() {
  for (int i = 0; i < numRockets; i++) {
    pop.setFitness();
  }
  String avg = roundDigits(pop.getAverageFitness(), 6);
  String best = roundDigits(pop.getBestFitness(), 6);
  Population test = pop.evolve();
  pop = test;
  generationCount++;
  moveCount = 0;
  println("REPORT: Generation #" + (generationCount - 1) + ": Average fitness: " + avg + " Best fitness: " + best);
}

 public String roundDigits(float num, int digits){ //rounds a decimal from 0-1 to a certain amount of digits
  if(num > 1 || num < 0) return "[Limit of input exceeded]";
  if(!(digits > 0)) return "[Invalid number of digits]";
  String str = String.valueOf(round(num * pow(10, digits)) / pow(10, digits));
  for(int i = str.length() - 1; i < digits + 1; i++){
    str += "0";
  }
  return str;
}
public class Gene {
  private boolean[] genotype;

  Gene(int geneLength) {
    genotype = new boolean[geneLength];
  }

  Gene(Gene original) {
    this(original.getGenotype().length);
    arrayCopy(original.getGenotype(), genotype);
  }

  public int getValue() {
    int value = 0;
    //converts to base10 from the back, and ending at the front
    for (int i = genotype.length - 1; i >= 0; i--) value += genotype[i] ? pow(2, genotype.length - (i + 1)) : 0;
    return value;
  }

  public void mutate() {
    int randomInd = PApplet.parseInt(random(genotype.length));
    genotype[randomInd] = !genotype[randomInd];
  }

  public String toString() {
    String ans = "BE->";
    for (boolean b : genotype) ans += b ? "1" : "0";
    return ans + " " + getValue();
  }

  public void setGenotype(boolean[] genotype) {
    arrayCopy(genotype, this.genotype);
  }

  public void setGenotype(int[] genotype) { //converts from binary 1s and 0s to boolean
    for (int i = 0; i < this.genotype.length; i++) this.genotype[i] = genotype[i] == 1;
  }

  public void randomize() {
    boolean[] newGenotype = new boolean[genotype.length];
    for (int i = 0; i < genotype.length; i++) {
      newGenotype[i] = PApplet.parseInt(random(2)) == 0;
    }
    setGenotype(newGenotype);
  }

  public boolean[] getGenotype() {
    return genotype;
  }
}
public static final int CHROMOSOME_LENGTH = 600; //length of chromosome
public static final int ACTIONS_LENGTH = 300; //length of actions, first [ACTIONS_LENGTH] genes of chromosome are magnitude, next [ACTIONS_LENGTH] genes are angle

public enum GeneLengths {
  //magnitude comes in increments of 1/150, up to 0.1
  //angle should be be in increments of (2 * PI)/511, up to 2 PI
  MAGNITUDE(4),
    ANGLE(9);

  private int length;

  private GeneLengths(int length) {
    this.length = length;
  }

  private int getLength() {
    return length;
  }
}

public class Individual {
  private Gene[] chromosome;
  private Rocket rocket;
  private float fitness = 0;

  public Individual(boolean random) {
    chromosome = new Gene[CHROMOSOME_LENGTH];
    for (int i = 0; i < ACTIONS_LENGTH; i++) {
      chromosome[i] = new Gene(GeneLengths.MAGNITUDE.getLength());
      chromosome[i + ACTIONS_LENGTH] = new Gene(GeneLengths.ANGLE.getLength());
    }
    if (random) for (Gene g : chromosome) g.randomize();
    else setRocket();
  }

  public Individual() {
    this(false);
  }

  public String toString() {
    StringBuilder sb = new StringBuilder();
    for (Gene g : chromosome) {
      sb.append(g.toString() + "|");
    }
    return sb.toString();
  }

  public void display(boolean showFitness, boolean highlight) {
    rocket.display(highlight);
    fill(0);
    if (showFitness) text(fitness, rocket.position.x, rocket.position.y);
  }

  public float getX() {
    return rocket.position.x;
  }

  public float getY() {
    return rocket.position.y;
  }

  public float getFitness() {
    return fitness;
  }

  public Gene[] getChromosome() {
    return chromosome;
  }
  
  public float getRocketSize(){
    return rocket.r;
  }

  public void setRocket() {
    PVector[] angles = new PVector[ACTIONS_LENGTH];
    float[] mags = new float[ACTIONS_LENGTH];
    for (int i = ACTIONS_LENGTH; i < 2 * ACTIONS_LENGTH; i++) {
      float theta = PApplet.parseFloat(chromosome[i].getValue()) * (2 * PI) / 511f;
      angles[i - ACTIONS_LENGTH] = new PVector(cos(theta), sin(theta));
      mags[i - ACTIONS_LENGTH] = PApplet.parseFloat(chromosome[i - ACTIONS_LENGTH].getValue()) / (2*150f);
    }
    rocket = new Rocket(angles, mags, ACTIONS_LENGTH);
  }

  public void resetRocket() {
    rocket.reset();
    setRocket();
  }

  public void moveRocket() {
    rocket.run();
  }

  public void mutate(float rate) {
    for (Gene g : chromosome) if (random(1) < rate) g.mutate();
  }

  public Individual crossover(Individual partner) {
    Individual child = new Individual(true);
    for (int i = 0; i < CHROMOSOME_LENGTH; i++) {
      if (random(1) < 0.5f) child.chromosome[i] = new Gene(chromosome[i]);
      else child.chromosome[i] = new Gene(partner.chromosome[i]);
    }
    child.setRocket();
    return child;
  }

  public void updateFitness(int x, int y) { //update fitness based on the center of the goal
    //update fitness based on distance from x, y
    fitness = pow(max(0, 1 - (dist(x, y, rocket.position.x, rocket.position.y) / max(max(dist(width, 0, goalX, goalY), dist(width, height, goalX, goalY)), max(dist(0, 0, goalX, goalY), dist(0, height, goalX, goalY))))), 3);
    //fitness = 1 / dist(x, y, getX(), getY());
  }
}
class Population {
  private Individual[] pop;
  private float totalFitness;
  private float mutationRate;
  private int goalX, goalY, goalSideLength;

  Population(int popSize) {
    this(popSize, 0.05f);
  }

  Population(int popSize, float mutationRate) {
    pop = new Individual[popSize];
    totalFitness = 0.0f;
    if (mutationRate > 1 || mutationRate <= 0) mutationRate = 0.05f;
    this.mutationRate = mutationRate;
  }
 
  public float getMutationRate() {
    return mutationRate;
  }

  public float getTotalFitness() {
    return totalFitness;
  }

  public Individual get(int ind) {
    return pop[ind];
  }

  public void display(boolean showFitness, boolean move) {
    for (int i = 0; i < pop.length; i++) {
      float posX = pop[i].getX();
      float posY = pop[i].getY();
      //if inside border and move is true
      if (posX >= 0 && posX <= width && posY >= 0 && posY <= height && move) {
        //if not touching goal
        if (!(posX >= goalX - (0.3f * goalSideLength) && posX <= goalX + (0.3f * goalSideLength) && posY >= goalY - (0.3f * goalSideLength) && posY <= goalY + (0.3f * goalSideLength))) {
          //if not touchign any of the obstacles from obstacles[][]
          boolean contact = false;
          for(int j = 0; j < obstacles.length; j++){
            if(!obstaclesEnabled) break;
            float phw = 0.5f * obstacles[j][2]; //placeholder width (0.5 * width)
            float phh = 0.5f * obstacles[j][3]; //placeholder height (0.5 * height)
            if(posX >= obstacles[j][0] - phw - pop[i].getRocketSize() && posX <= obstacles[j][0] + phw + pop[i].getRocketSize() && posY >= obstacles[j][1] - phh - pop[i].getRocketSize() && posY <= obstacles[j][1] + phh + pop[i].getRocketSize()){
              contact = true;
              break;
            } 
          }
          if(!contact) pop[i].moveRocket();  
        }
      }
      if(i == getBestIndex()) pop[i].display(showFitness, true);
      else pop[i].display(showFitness, false);
    }
  }

  public void setGoal(int x, int y, int sideLength) {
    goalX = x;
    goalY = y;
    goalSideLength = sideLength;
  }
  public void setFitness() {
    totalFitness = 0;
    for (int i = 0; i < pop.length; i++) {
      pop[i].updateFitness(goalX, goalY);
      totalFitness += pop[i].getFitness();
    }
  }

  public int getBestIndex() {
    float bestFitness = 0.0f;
    int bestIndex = 0;
    for (int i = 1; i < pop.length; i++) {
      if (pop[i].getFitness() > bestFitness) {
        bestFitness = pop[i].getFitness();
        bestIndex = i;
      }
    }
    return bestIndex;
  }

  public float getBestFitness() {
    float bestFitness = 0.0f;
    for (int i = 1; i < pop.length; i++) {
      if (pop[i].getFitness() > bestFitness) {
        bestFitness = pop[i].getFitness();
      }
    }
    return bestFitness;
  }

  public float getAverageFitness() {
    return totalFitness / PApplet.parseFloat(pop.length);
  }

  public void set(int index, Individual indiv) {
    pop[index] = indiv;
  }

  public void setMutationRate(float mutationRate) {
    if (mutationRate > 1) mutationRate = 1;
    if (mutationRate <= 0.001f) mutationRate = 0.001f;
    this.mutationRate = mutationRate;
  }

  public void setup() {
    for (Individual i : pop) i.setRocket();
  }

  public Individual select() {
    float sumFitness = 0;
    float aimFitness = random(1, totalFitness);
    for (int i = 1; i < pop.length; i++) {
      sumFitness += pop[i].getFitness();
      if (sumFitness >= aimFitness) return pop[i];
    }
    return pop[pop.length-1];
  }

  public void randomPop() {
    for (int i = 0; i < pop.length; i++) {
      pop[i] = new Individual(true);
    }
    setup();
  }

  public Population evolve() {
    Population newPop = new Population(pop.length, mutationRate);
    newPop.setGoal(goalX, goalY, goalSideLength);
    int bestInd = getBestIndex();
    for (int i = 0; i < pop.length; i++) {
      if (i == bestInd) {
        pop[i].resetRocket();
        newPop.set(i, pop[i]);
        continue;
      }

      Individual parent1 = select();
      Individual parent2 = select();
      Individual child = parent1.crossover(parent2);
      child.mutate(mutationRate);
      child.resetRocket();
      newPop.set(i, child);
    }
    return newPop;
  }
}
class Rocket {

  static final int START_X = 50;
  static final int START_Y = 250;

  // All of our physics stuff
  PVector position;
  PVector velocity;
  PVector acceleration;
  PVector[] angles;
  float[] mags;
  int moveCount;
  // Size
  float r;


  Rocket(PVector l, int numMoves) {
    acceleration = new PVector();
    velocity = new PVector();
    angles = new PVector[numMoves];
    mags = new float[numMoves];
    position = l.copy();
    moveCount = 0;
    r = 4;
  }

  Rocket(PVector[] as, float[] ms, int numMoves) {
    this(new PVector(START_X, START_Y), numMoves);
    angles = as;
    mags = ms;
  }

   public void randomMoves() {
    for (int m=0; m < angles.length; m++) {
      float theta = random(TWO_PI);
      angles[m] = new PVector(cos(theta), sin(theta));
      mags[m] = random(0.1f);
    }
  }

   public void reset() {
    acceleration = new PVector();
    velocity = new PVector();
    position = new PVector(START_X, START_Y);
    moveCount = 0;
  }

   public void run() {
    PVector move = angles[moveCount].copy();
    move.mult(mags[moveCount]);
    applyForce(move);
    moveCount = (moveCount+1) % angles.length;
    update();
  }


   public void applyForce(PVector f) {
    acceleration.add(f);
  }

   public void update() {
    velocity.add(acceleration);
    position.add(velocity);
    acceleration.mult(0);
  }

   public void display(boolean highlight) {
    float theta = velocity.heading() + PI/2;
    fill(200, 100);
    stroke(0);
    pushMatrix();
    translate(position.x, position.y);
    /*
    fill(0);
     text(position.x + " " + position.y, 0, 0);
     */
    rotate(theta);

    // Thrusters
    rectMode(CENTER);
    fill(0);
    if(highlight) fill(255);
    rect(-r/2, r*2, r/2, r);
    rect(r/2, r*2, r/2, r);

    // Rocket body
    fill(175);
    if(highlight) fill(100, 210, 255);
    beginShape(TRIANGLES);
    vertex(0, -r*2);
    vertex(-r, r*2);
    vertex(r, r*2);
    endShape();

    popMatrix();
    rectMode(CORNER);
  }
}


  public void settings() { size(500, 500); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "RocketLab" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}

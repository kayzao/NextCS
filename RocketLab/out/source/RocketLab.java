/* autogenerated by Processing revision 1282 on 2022-04-14 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class RocketLab extends PApplet {

int NUM_MOVES = 500;
int goalX;
int goalY;
int goalSideLength = 50;
int moveCount;
int numRockets = 20;
int generationCount = 0;
Population pop;

 public void setup() {
  /* size commented out by preprocessor */;
  goalX = width - 50;
  goalY = height / 2;
  pop = new Population(numRockets);
  pop.randomPop();
  moveCount = 0;
  println("Generation: " + generationCount);
  pop.setFitness(goalX, goalY);
}
 public void draw(){
  background(255);
  drawGoal();
  if (moveCount <= NUM_MOVES) {
    pop.display(false);
    moveCount++;
  } else {
    pop.display(true);
  }
  pop.setFitness(goalX, goalY);
}
 public void keyPressed(){
  
  if(key == 'r'){
    pop.randomPop();
    moveCount = 0;
    generationCount = 0;
  }

  if(key == ' ' && moveCount > NUM_MOVES){
    for(int i = 0; i < numRockets; i++){
      pop.setFitness(goalX, goalY);
    }
    Population test = pop.evolve();
    pop = test;
    generationCount++;
    moveCount = 0;
    println("Generation: " + generationCount + " Average fitness: " + pop.getAverageFitness());
  }
}

 public void drawGoal(){
  fill(255, 255, 0);
  stroke(255);
  strokeWeight(1);
  rect(goalX, goalY, goalSideLength / 2, goalSideLength / 2);
}
public class Gene {
  private boolean[] genotype;

  Gene(int geneLength) {
    genotype = new boolean[geneLength];
  }

  Gene(Gene original) {
    this(original.getGenotype().length);
    arrayCopy(original.getGenotype(), genotype);
  }
  
  public int getValue() {
    int value = 0;
    //converts to base10 from the back, and ending at the front
    for (int i = genotype.length - 1; i >= 0; i--) value += genotype[i] ? pow(2, genotype.length - (i + 1)) : 0;
    return value;
  }

  public void mutate() {
    int randomInd = PApplet.parseInt(random(genotype.length));
    genotype[randomInd] = !genotype[randomInd];
  }

  public String toString() {
    String ans = "BE->";
    for (boolean b : genotype) ans += b ? "1" : "0";
    return ans + " " + getValue();
  }

  public void setGenotype(boolean[] genotype) {
    arrayCopy(genotype, this.genotype);
  }

  public void setGenotype(int[] genotype) { //converts from binary 1s and 0s to boolean
    for (int i = 0; i < this.genotype.length; i++) this.genotype[i] = genotype[i] == 1;
  }

  public void randomize() {
    boolean[] newGenotype = new boolean[genotype.length];
    for (int i = 0; i < genotype.length; i++) {
      newGenotype[i] = PApplet.parseInt(random(2)) == 0;
    }
    setGenotype(newGenotype);
  }

  public boolean[] getGenotype() {
    return genotype;
  }
}
public static final int CHROMOSOME_LENGTH = 200; //first 50 for magnitude, last 50 for angle
public static final int ACTIONS_LENGTH = 100;

public enum GeneLengths { 
  //magnitude comes in increments of 1/150, up to 0.1
  //angle should be be in increments of (2 * PI)/511, up to 2 PI
  MAGNITUDE(4),
  ANGLE(9);

  private int length;
  
  private GeneLengths(int length) {
    this.length = length;
  }

  private int getLength() {
    return length;
  }
}

public class Individual{
  private Gene[] chromosome;
  public Rocket rocket;
  private float fitness = 0;

  public Individual(boolean random){
    chromosome = new Gene[CHROMOSOME_LENGTH];
    for(int i = 0; i < ACTIONS_LENGTH; i++){
      chromosome[i] = new Gene(GeneLengths.MAGNITUDE.getLength());
      chromosome[i + ACTIONS_LENGTH] = new Gene(GeneLengths.ANGLE.getLength());
    }
    if(random) for(Gene g : chromosome) g.randomize();
    else setRocket();
  }
  public Individual(){
    this(false);
  }

  public String toString(){
    StringBuilder sb = new StringBuilder();
    for(Gene g : chromosome){
      sb.append(g.toString() + "|");
    }
    return sb.toString();
  }

  public void display(boolean showFitness){
    rocket.display();
    fill(0);
    if(showFitness) text(fitness , rocket.position.x, rocket.position.y);
  }

  public float getFitness(){
    return fitness;
  }

  public Gene[] getChromosome(){
    return chromosome;
  }

  public void setRocket(){
    PVector[] angles = new PVector[ACTIONS_LENGTH];
    float[] mags = new float[ACTIONS_LENGTH];
    for(int i = ACTIONS_LENGTH; i < 2 * ACTIONS_LENGTH; i++){
      float theta = PApplet.parseFloat(chromosome[i].getValue()) * (2 * PI) / 511f;
      angles[i - ACTIONS_LENGTH] = new PVector(cos(theta), sin(theta));
      mags[i - ACTIONS_LENGTH] = PApplet.parseFloat(chromosome[i - ACTIONS_LENGTH].getValue()) / 150f;
    }
    rocket = new Rocket(angles, mags, ACTIONS_LENGTH);
  }

  public void mutate(float rate){
    for(Gene g : chromosome) if(random(1) < rate) g.mutate();
  }

  public Individual crossover(Individual partner){
    Individual child = new Individual(true);
    for(int i = 0; i < CHROMOSOME_LENGTH; i++){
      if(random(1) < 0.5f) child.chromosome[i] = new Gene(chromosome[i]);
      else child.chromosome[i] = new Gene(partner.chromosome[i]);
    }
    child.setRocket();
    return child;
  }

  public void updateFitness(int x, int y){ //update fitness based on the center of the goal
    //update fitness based on distance from x, y.
    //FORMULA: 1/distance
    fitness = 1 / dist(x, y, rocket.position.x, rocket.position.y);
    text(fitness, rocket.position.x, rocket.position.y);
  }
}
class Population{
  private Individual[] pop;
  private float totalFitness;
  private float mutationRate;
    
  Population(int popSize) {
    this(popSize, 0.05f);
  }

  Population(int popSize, float mutationRate){
    pop = new Individual[popSize];
    totalFitness = 0.0f;
    this.mutationRate = mutationRate;
  }

  public float getMutationRate(){
    return mutationRate;
  }

  public float getTotalFitness(){
    return totalFitness;
  }

  public Individual get(int ind){
    return pop[ind];
  }
  
  public void display(boolean showFitness){
    for(int i = 0; i < pop.length; i++){
      if(!showFitness) pop[i].rocket.run();
      pop[i].display(showFitness);
    }
  }

  public void setFitness(int x, int y){
    totalFitness = 0;
    for(int i = 0; i < pop.length; i++){
      pop[i].updateFitness(x, y);
      totalFitness += pop[i].getFitness();
    }
  }

  public int getBestIndex(){
    float bestFitness = 0.0f;
    int bestIndex = 0;
    for(int i = 1; i < pop.length; i++){
      if(pop[i].getFitness() > bestFitness){
        bestFitness = pop[i].getFitness();
        bestIndex = i;
      }
    }
    return bestIndex;
  }
  
  public float getBestFitness(){
    float bestFitness = 0.0f;
    for(int i = 1; i < pop.length; i++){
      if(pop[i].getFitness() > bestFitness){
        bestFitness = pop[i].getFitness();
      }
    }
    return bestFitness;
  }

  public float getAverageFitness(){
    return totalFitness / PApplet.parseFloat(pop.length);
  }
  
  public void set(int index, Individual indiv){
    pop[index] = indiv;
  }

  public void setup(){
    for(Individual i : pop) i.setRocket();
  }

  public Individual select(){
    float sumFitness = 0;
    float aimFitness = random(1, totalFitness);
    for(int i = 1; i < pop.length; i++){
      sumFitness += pop[i].getFitness();
      if(sumFitness >= aimFitness) return pop[i];
    }
    return pop[pop.length-1];
  }
  
  public void randomPop() {
    for (int i = 0; i < pop.length; i++) {
      pop[i] = new Individual(true);
    }
    setup();
  }

  public Population evolve(){ 
    Population newPop = new Population(pop.length, mutationRate);
    int bestInd = getBestIndex();
    for(int i = 0; i < pop.length; i++){
      /*
      if(i == bestInd){
        newPop.set(i, pop[i]);
        continue;
      } */
      Individual parent1 = select();
      Individual parent2 = select();
      Individual child = parent1.crossover(parent2);
      child.mutate(mutationRate);
      child.rocket.reset();
      child.setRocket();
      newPop.set(i, child);
    }
    return newPop;
  }
    
}
class Rocket {

  static final int START_X = 50;
  static final int START_Y = 250;

  // All of our physics stuff
  PVector position;
  PVector velocity;
  PVector acceleration;
  PVector[] angles;
  float[] mags;
  int moveCount;
  // Size
  float r;


  Rocket(PVector l, int numMoves) {
    acceleration = new PVector();
    velocity = new PVector();
    angles = new PVector[numMoves];
    mags = new float[numMoves];
    position = l.copy();
    moveCount = 0;
    r = 4;
  }

  Rocket(PVector[] as, float[] ms, int numMoves) {
    this(new PVector(START_X, START_Y), numMoves);
    angles = as;
    mags = ms;
  }

   public void randomMoves() {
    for (int m=0; m < angles.length; m++) {
      float theta = random(TWO_PI);
      angles[m] = new PVector(cos(theta), sin(theta));
      mags[m] = random(0.1f);
    }
  }

   public void reset() {
    acceleration = new PVector();
    velocity = new PVector();
    position = new PVector(START_X, START_Y);
    moveCount = 0;
  }

   public void run() {
    PVector move = angles[moveCount].copy();
    move.mult(mags[moveCount]);
    applyForce(move);
    moveCount = (moveCount+1) % angles.length;
    update();
  }


   public void applyForce(PVector f) {
    acceleration.add(f);
  }

   public void update() {
    velocity.add(acceleration);
    position.add(velocity);
    acceleration.mult(0);
  }

   public void display() {
    float theta = velocity.heading() + PI/2;
    fill(200, 100);
    stroke(0);
    pushMatrix();
    translate(position.x, position.y);
    /*
    fill(0);
    text(position.x + " " + position.y, 0, 0);
    */
    rotate(theta);
    
    // Thrusters
    rectMode(CENTER);
    fill(0);
    rect(-r/2, r*2, r/2, r);
    rect(r/2, r*2, r/2, r);

    // Rocket body
    fill(175);
    beginShape(TRIANGLES);
    vertex(0, -r*2);
    vertex(-r, r*2);
    vertex(r, r*2);
    endShape();

    popMatrix();
  }

}


  public void settings() { size(500, 500); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "RocketLab" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
